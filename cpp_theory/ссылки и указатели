===== Указатели ======
При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется по этому адресу в памяти.


Пример:
--------------------------------------------------------------------------
INPUT:
#include <iostream>

int main()
{
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес памяти переменной a

    return 0;
}


OUTPUT:
7
0046FCF0



INPUT:
#include <iostream>

int main()
{
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес переменной a
    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a

    return 0;
}
OUTPUT:
7
0046FCF0
7
--------------------------------------------------------------------------

Итак, указатель - это переменная, значением которой является адрес ячейки памяти. Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой между типом данных и идентификатором:

int *iPtr; // указатель на значение типа int
double *dPtr; // указатель на значение типа double


int value = 5;
int *ptr = &value; // инициализируем ptr адресом значения переменной


Пример:
--------------------------------------------------------------------------
INPUT:
#include <iostream>

int main()
{
    int value = 5;
    int *ptr = &value; // инициализируем ptr адресом значения переменной

    std::cout << &value << '\n'; // выводим адрес значения переменной value
    std::cout << ptr << '\n'; // выводим адрес, который хранит ptr

    return 0;
}

OUTPUT:
003AFCD4
003AFCD4
--------------------------------------------------------------------------

Как только у нас есть указатель, указывающий на что-либо, мы можем его разыменовать, чтобы получить значение, на которое он указывает. Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает:
int value = 5;
	std::cout << &value << std::endl; // выводим адрес value
	std::cout << value << std::endl; // выводим содержимое value

	int *ptr = &value; // ptr указывает на value
	std::cout << ptr << std::endl; // выводим адрес, который хранится в ptr, т.е. &value
	std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)


«Указатель на массив». Строго говоря, «указатель на массив» — это именно указатель на массив и ничто другое. Иными словами:

int (*a)[2]; // Это указатель на массив. Самый настоящий. Он имеет тип int (*TYPE)[2]
int b[2];
int *c = b; // Это не указатель на массив. Это просто указатель. Указатель на первый элемент некоего массива
int *d = new int[4]; // И это не указатель на массив. Это указатель


Однако, иногда под фразой «указатель на массив» неформально понимают указатель на область памяти, в которой размещён массив, даже если тип у этого указателя неподходящий. В соответствии с таким неформальным пониманием c и d (и b + 0) — это указатели на массивы.


#include <iostream>

void foo1(){    std::cout << "foo1\n";  }
void foo2(){    std::cout << "foo2\n";  }

int main()
{
    void (*pf1)() = &foo1;
    void (*pf2)() = &foo2;

    void (*arr_func[2])() = {pf1,pf2}; //массив функций

    for (int i=0; i<2;i++)   arr_func[i]();
}


